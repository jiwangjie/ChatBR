{"id": "41952", "title": "Bug 41952XLint warning for call PCD's using subtype of defining type", "description": " Bug 41952XLint warning for call PCD's using subtype of defining type Some would like an XLint compiler warning when the user in a call PCD specifiesa declaring type that is not the defining type, because that constrains the joinpoints to those whose bytecode signature contain the specified type as thedeclaring type.e.g.,class A { void run() {} }class B extends A {}aspect C {before() : call(void B.run()) { } // warn here}public class Main {public static void main(String[] args) {// ok with 1.4; otherwise, becomes A.run in bytecodenew B().run();// never workscompiletime type of reference is A, not B((A) new B()).run();}This warning is useful for two reasons.First, the user probably intended thatany call to an instance of that object be picked out (regardless of thecompiletime type of the reference used to make the call), and thus should usetarget(B) && call(void run())(This suggestion could be in the XLint message.", "OB": " )Second, older compilers (i.e., compilers not using 1.4) would incorrectlyspecify the declaring type of the method call as the first type in the hierarchywhich defined the method, so even if the user meant to constrain the join pointby the compiletime reference type, the bytecode signature could be incorrectand the pointcut fail to pick out the join point.One problem with this XLint warning is that is also picks out valid declarewarning/error statements enforcing requirements at compiletime about the typeof the reference used to invoke a method (e.g., when using a static reference ofthe wrong type).So perhaps the default level should be ignore.See also bug 41888.", "EB": "", "SR": ""}