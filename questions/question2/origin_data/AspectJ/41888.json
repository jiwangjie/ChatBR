{"bug_id": "41888", "title": "Bug 41888call PCD fails when given subtype of defining type", "description": "AspectJ 1.0 and 1.1 are behaving differently with respect to the qualifying typein a method call PCD. See the test casetests/bugs/CallReference.javaAspectJ 1.1 is not picking out join points when a subtype of the defining typeis used.I assume 1.0 is correct (but see [1]) because it tracks the programming guide(and the JLS). Because this might involve questions about what's correct, I'llinclude (my understanding of) the definition here in case the fix is to correctmy interpretation or the programming guide.The programming guide says,At a method call join point, the signature is a method signaturewhose qualifying type is the static type used to access the method.So givenclass Super { void run() {} }class Sub extends Super { }class SubSub extends Sub { }Super is the declaring and defining type for run().For the callnew SubSub().run()SubSub is the qualifying type because the reference type qualifies the call.(i.e., because method dispatch occurs at runtime, with a search up the hierarchyif a method is not implemented directly in the class of the object.i.e., theguide intends to follow the definition of qualifying type for methods used inJLS 13.1.)Further, I understood from Erik that AspectJ accounts for polymorphism by havingthe pointcut match if one specifies a supertype of the signature type, so longas the method was defined in the specified supertype (or one of its supertypes).So to pick out all calls to that method, one should use the declaring type (inthis case, Super); to restrict the calls matched, use a subtype.Indeed, forthis reason, the locutiontarget(Sub) && call(void run())evolved to address the situation where the method was being invoked through asupertype reference, e.g.,((Super) new SubSub()).run()which would only be picked out bycall(void Super.run())and not bycall(void SubSub.run())even when the method was implemented in SubSub.This is the behavior of AspectJ 1.0.By contrast, AspectJ 1.1, givencall(void Sub.run())fails to pick out the invocationsnew Sub().run()new SubSub().run()though it would pick outnew Sub().run()if the method were also defined in Sub, and not just in Super.Side notes:[1] In AspectJ 1.0, if I print the signature of the join point, it emits thedefining type of the method as the type, and does not change depending on thestatic type used to access the method. That would seem to be a 1.0 (and 1.1?)limitation of the JoinPoint signature.[2] This should not be related to the case where older compilers use thedeclaring type of the method as the qualifying type, since this bug occurs whenall sources are presented to ajc. I.e., the programming guide alreadyincorporates the Java 1.01.1 change described in \"Compilation of SymbolicReferences\": http://java.sun.com/docs/books/jls/clarify.html http://java.sun.com/docs/books/jls/publicsymrefcompilationrules.html"}