{"bug_id": "153535", "title": "Bug 153535Bug in reflection delegate signature for array of object type", "description": "The following problem is interesting because the advice weaves correctly with Java 1.5 LTW and also using Java 1.4 with buildtime weaving. However, the following call pointcut isn't matching the expected call site in Java 1.4 loadtime weaving ().Pointcut:private pointcut inExecQuery() :(within(uk.ltd.getahead.dwr.impl.ExecuteQuery) || within(uk.ltd.getahead.dwr.ExecuteQuery));public pointcut dwrQuery(Method method, Object receiver, Object[] params) :inExecQuery() && withincode( execute(..)) &&call( Method.invoke(..)) && args(receiver, params) && target(method);protected pointcut monitorEnd() : dwrQuery(, , );Matching call site:Object reply = method.invoke(object, params);I've tracked it down to failing to find the method in ResolvedType.matches. On line 405:\"m1.getSignature()\"= \"(Ljava/lang/Object;[Ljava.lang.Object;)Ljava/lang/Object;\"\"m2.getSignature()\"= \"(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\"Note the difference between . and /^^It looks to me like the signature for array types in the reflection delegate is erroneously using . instead of /. I have attached a patch to the ReflectionBasedReferenceTypeDelegateTest that isolates this unexpected signature return. Hopefully you agree that this is not correct. If not, some more information follows.Here's the stack trace where the match fails:ResolvedType.matches(Member, Member) line: 405ReferenceType(ResolvedType).lookupMember(Member, Iterator) line: 347ReferenceType(ResolvedType).lookupMethod(Member) line: 326LTWWorld(World).resolve(Member) line: 504MemberImpl.resolve(World) line: 93JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember() line: 109JoinPointSignatureIterator.<init(Member, World) line: 51MemberImpl.getJoinPointSignatures(World) line: 943SignaturePattern.matches(Member, World, boolean) line: 286KindedPointcut.matchInternal(Shadow) line: 106KindedPointcut(Pointcut).match(Shadow) line: 146AndPointcut.matchInternal(Shadow) line: 53AndPointcut(Pointcut).match(Shadow) line: 146AndPointcut.matchInternal(Shadow) line: 51AndPointcut(Pointcut).match(Shadow) line: 146AndPointcut.matchInternal(Shadow) line: 51AndPointcut(Pointcut).match(Shadow) line: 146AndPointcut.matchInternal(Shadow) line: 51AndPointcut(Pointcut).match(Shadow) line: 146OrPointcut.matchInternal(Shadow) line: 50OrPointcut(Pointcut).match(Shadow) line: 146BcelAdvice(ShadowMunger).match(Shadow, World) line: 71BcelAdvice(Advice).match(Shadow, World) line: 112BcelAdvice.match(Shadow, World) line: 107BcelClassWeaver.match(BcelShadow, List) line: 2806BcelClassWeaver.matchInvokeInstruction(LazyMethodGen, InstructionHandle, InvokeInstruction, BcelShadow, List) line: 2768BcelClassWeaver.match(LazyMethodGen, InstructionHandle, BcelShadow, List) line: 2506BcelClassWeaver.match(LazyMethodGen) line: 2332BcelClassWeaver.weave() line: 494BcelClassWeaver.weave(BcelWorld, LazyClassGen, List, List, List) line: 119BcelWeaver.weave(UnwovenClassFile, BcelObjectType, boolean) line: 1613BcelWeaver.weaveWithoutDump(UnwovenClassFile, BcelObjectType) line: 1564BcelWeaver.weaveAndNotify(UnwovenClassFile, BcelObjectType, IWeaveRequestor) line: 1341BcelWeaver.weave(IClassFileProvider) line: 1163ClassLoaderWeavingAdaptor(WeavingAdaptor).getWovenBytes(String, byte[]) line: 319ClassLoaderWeavingAdaptor(WeavingAdaptor).weaveClass(String, byte[]) line: 225Aj.preProcess(String, byte[], ClassLoader) line: 77ClassPreProcessorAdapter.preProcess(String, byte[], ClassLoader) line: 67ClassPreProcessorHelper.defineClass0Pre(ClassLoader, String, byte[], int, int, ProtectionDomain) line: 107WebappClassLoader(ClassLoader).defineClass(String, byte[], int, int, ProtectionDomain) line: 539WebappClassLoader(SecureClassLoader).defineClass(String, byte[], int, int, CodeSource) line: 123WebappClassLoader.findClassInternal(String) line: 1786WebappClassLoader.findClass(String) line: 1048WebappClassLoader.loadClass(String, boolean) line: 1506WebappClassLoader.loadClass(String) line: 1385WebappClassLoader(ClassLoader).loadClassInternal(String) line: 302Class.forName0(String, boolean, ClassLoader) line: not available [native method]Class.forName(String) line: 141InitializeLog.setWarnLogging(String) line: 121InitializeLog.initializeLogging() line: 96ContextLoaderServlet.init() line: 13ContextLoaderServlet(GenericServlet).init(ServletConfig) line: 212StandardWrapper.loadServlet() line: 879StandardWrapper.load() line: 767StandardContext.loadOnStartup(Container[]) line: 3483StandardContext.start() line: 3709StandardHost(ContainerBase).addChildInternal(Container) line: 776StandardHost(ContainerBase).addChild(Container) line: 759StandardHost.addChild(Container) line: 537StandardHostDeployer.install(String, URL) line: 260StandardHost.install(String, URL) line: 730HostConfig.deployWARs(File, String[]) line: 558HostConfig.deployApps() line: 373HostConfig.start() line: 784HostConfig.lifecycleEvent(LifecycleEvent) line: 330LifecycleSupport.fireLifecycleEvent(String, Object) line: 119StandardHost(ContainerBase).start() line: 1155StandardHost.start() line: 696StandardEngine(ContainerBase).start() line: 1147StandardEngine.start() line: 310StandardService.start() line: 449StandardServer.start() line: 2212Catalina.start() line: 458Catalina.execute() line: 345Catalina.process(String[]) line: 129NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]NativeMethodAccessorImpl.invoke(Object, Object[]) line: 39DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25Method.invoke(Object, Object[]) line: 324Bootstrap.main(String[]) line: 150I'm using a modified version of Alex Vasseur's LTW plugin for a Java 1.4 VM although I haven't tested on the JRockIt plugin for a 1.4 VM: my guess is that this would fail there too."}