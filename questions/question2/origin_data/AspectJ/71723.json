{"bug_id": "71723", "title": "Bug 71723Inconsistency in scoping of protected members in ITDs", "description": "When introducing new member functions to existing classes via intertypedeclarations, the scoping rules that apply to the ITD bodies are the same as forthe aspect  for example, private members of the target class cannot be accessedunless the aspect is privileged.Similarly, protected members of classes in different packages should not bevisible in ITDs unless the aspect is privileged.This rule is only enforced for protected members declared in the target class protected members that are inherited are visible from ITDs in aspects indifferent packages.The following is an example of this:package foo;public class Foo extends AncientFoo {protected int i() { return 42; }public static void main(String[] args) {new Foo().doStuff();}public void doStuff() { }protected int ancientI() { return 42; }}class AncientFoo {protected int ancientI() { return 42; }protected int ancientJ() { return 0; }}package bar;import foo.Foo;aspect Bar {public void Foo.doing() {try {System.out.println(i()); // fails in ajcSystem.out.println(ancientI()); // fails in ajcSystem.out.println(ancientJ()); // succeedsSystem.out.println(clone()); // succeeds}catch(Throwable t) { }}before(Foo f) : call( doStuff(..)) && target(f) {f.doing();}}All four calls in Foo.doing() should fail, as they refer to protected members offoo.Foo from package bar. However, only the first 2  the ones directlydeclared/overridden in foo.Foo  are detected as errors, and removing them makesthe rest compile and execute.Best wishes,Pavel"}